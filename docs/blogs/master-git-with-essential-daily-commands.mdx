![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62ed60394a15f407229b0046_master_git.png)
"git; developer-workflow"
# Master Git With Essential Daily Commands
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<p id="">Since the founding of Git back in 2005 by <a href="https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux" target="_blank" id=""><strong id="">Linus Torvalds</strong></a>, the software industry has transformed dramatically to rely heavily upon the technology for version control to track files. Currently, nearly every programming team in the professional world is using Git, and there is really almost no serious challenger out there especially with code hosting services like Github, Bitbucket, and Gitlab causing even further adoption.<p.new.line><p id="">In this article, I will explain some of the commands I use every day in Git to allow me to stay productive while managing my own code. Hopefully, after this, you will be able to come away with some helpful commands and have some you even want to save!<p.new.line><h2 id="">Resetting<h2.new.line><p id="">The <em id="">git reset</em> command is used to reset the <em id="">HEAD</em> to a specific state. In this part, we will see a few ways to use it to achieve particular items.<p.new.line><h3 id="">Hard<h3.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f5499b46315b07e49678_raycast-untitled%20(7)-min.png" loading="lazy" id="" width="auto" height="auto" alt="The git reset command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=a57440b27c" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">The <em id="">reset</em> command, used with the <em id="">--hard</em> option, is a destructive operation that will rewrite your git history, so you must be extremely careful when using it. However, <em id="">reset --hard</em> can become very handy if you know what you’re doing.<p.new.line><p id="">To put your mind at ease, as long as you don’t push the changes to the remote server, you’re safe. Things get complicated when you rewrite the server Git history, as your unique source of truth (the server) is no longer the right source to follow.I like using <em id="">reset --hard</em> when I want to restart from another branch’s state. For instance, I typically use it when I want to rewrite a Git history of a working copy.<p.new.line><p id="">I reset my local branch to the state where it was initially, and then I better organize the working copy by getting the commits from the server one by one in an order that best suits.<p.new.line><h3 id="">Soft<h3.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f64da039f9d09f3b97bd_raycast-untitled%20(8)-min.png" loading="lazy" id="" width="auto" height="auto" alt="A git reset command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=a57440b27c" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">On the other hand, the <em id="">reset --soft</em> command is less destructive, as it will rewrite the Git history, but all the changes of each commit you reset will come back to you.<p.new.line><p id=""><em id="">reset --soft</em> is very handy when you’ve shipped one or multiple commits, but you realize that you want to restructure the way the commits are organized, as it allows you to <strong id="">reset</strong> to the starting point before you committed your changes.<p.new.line><h2 id="">Amending<h2.new.line><p id="">Enhance your <em id="">git commit</em> usage:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f68f68ea161a182346d1_raycast-untitled%20(9)-min.png" loading="lazy" id="" width="auto" height="auto" alt="A command to amend a git commit."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=235645aa1a" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Amending has a secret power. You should generally use this command to edit the commit message, but it can also be used to add more changes to an already committed commit.Indeed, if you stage the changes and apply an amend, the staged changes will be added to the commit.<p.new.line><p id="">You can even add <em id="">--no-edit</em> if you don't want to edit the commit message.However, that operation is seen as destructive, as it could rewrite the Git history since you’re adding changes to an already committed commit. So, you can only push it by using the <em id="">--force </em>option. Be careful when using it!<p.new.line><p id=""><strong id="">A small note</strong> on the <em id="">--force</em> option: I tend to use <em id="">--force-with-lease </em>more often, as it will protect you against a potential situation wherein someone pushes a commit while you rebase. It could save lives, as it won’t push and erase the commit that a co-worker pushed just before you.<p.new.line><h2 id="">Rebasing<h2.new.line><p id="">Reapply a commit on top of another base:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f6d06e8bed99f710aaac_raycast-untitled%20(10)-min.png" loading="lazy" id="" width="auto" height="auto" alt="A command to rebase a commit."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=235645aa1a" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Rebasing permits you to apply a commit on top of an existing commit, but it doesn't create an additional merge commit as <em id="">git merge</em> does. That command is usually used to keep your branch feature up-to-date with the <em id="">main/master</em> branch.<p.new.line><p id="">It applies all the missing commits from <em id="">main/master</em> to your branch.<p.new.line><h3 id="">Interactive Rebasing<h3.new.line><p id="">Enhance your rebasing by going interactive:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f6ff7d7bebaa48a3a284_raycast-untitled%20(11)-min.png" loading="lazy" id="" width="auto" height="auto" alt="An interactive rebasing command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=7331438535" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Interactive rebasing will give you more granularity and more power over how you want to organize your commit history. It's a convenient and powerful tool, but it can also be a source of confusion, as the commands are complex to assimilate.<p.new.line><p id="">Git will enter interactive mode to let you rebase interactively.<p.new.line><p id="">For instance, we want to update the last ten commits’ history in this real-world example.<p.new.line><p id="">Git provides a range of commands that will help us rewrite the history to our will:<p.new.line><ul id=""><li id="">pick<li.new.line><li id="">reword<li.new.line><li id="">edit<li.new.line><li id="">squash<li.new.line><li id="">fixup<li.new.line><ul.new.line><h4 id="">Reword<h4.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:701px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="701px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0ed698b8758c4f5486ecc_reword.png" loading="lazy" id="" width="auto" height="auto" alt="A collection of interactive rebase commands."><div.new.line><figure.new.line><p id="">If you want to run it, you have to transform the <em id="">pick</em> command into an <em id="">edit </em>command. Then you can save the file, and Git will open a new editor to let you update the commit you wanted to update.<p.new.line><p id=""><strong id="">Small tip:</strong> You can use the first letter of the command. In our case, it would be <em id="">e</em>.<p.new.line><h4 id="">Fixup<h4.new.line><p id="">The <em id="">fixup</em> command is convenient when you want to merge multiple commits into one.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:725px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="725px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d1176f12d3c8e5610a91b8_this_one-min.png" loading="lazy" id="" width="auto" height="auto" alt="Using the fixup command."><div.new.line><figure.new.line><p id="">For instance, if you created many commits while you were developing, but in the end, you realized that you could merge your commits to form a single commit, the fixup command can help you with that.In the example I gave above, we will make one single commit out of the commit <em id="">f9c4640c8d</em> and the previous commit <em id="">1c4d338cc2</em>, and the commit message will be the one of those mentioned above. You can use this command multiple times at once.<p.new.line><h4 id="">Squash<h4.new.line><p id="">The <em id="">squash </em>command is almost the same as the <em id="">fixup</em> command explained above, except that <em id="">squash</em> keeps the commit message of the squashed commit and inserts it into the previous commit.<p.new.line><h2 id="">Cherry-picking<h2.new.line><p id="">Applying the changes introduced by existing commits:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f7565f70f4c5e7d872a7_raycast-untitled%20(12)-min.png" loading="lazy" id="" width="auto" height="auto" alt="The cherry-picking command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=67b24792ac" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">For me, <em id="">cherry-picking</em> is the Git symbol of flexibility.<p.new.line><p id="">It allows you to pick a commit from a branch and apply it in your current branch.<p.new.line><p id="">You can also pick a range of commits to apply in your current branch:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1054px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1054px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f788f0c56e7287439927_raycast-untitled%20(13)-min.png" loading="lazy" id="" width="auto" height="auto" alt="Using the cherry-pick command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=44c0438c85" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id=""><strong id="">Tip: </strong>the minor <em id="">^</em> character includes a commit in the current commit. Otherwise, the <em id="">shaCommitOldest </em>would be excluded.<p.new.line><p id="">To give a real-world example, I usually heavily rely on this Git command when I want to completely rewrite the Git history of my feature. I use a <em id="">reset --hard</em>, which puts me up to date with <em id="">master/main</em>, and then I reapply the commits that I want from the server.<p.new.line><h2 id="">Applying changes from specific branches/commits on specific files<h2.new.line><p id="">Ever wanted to reset a file's state from an existing commit?<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f7c0a039f954cf3b9e76_raycast-untitled%20(14)-min.png" loading="lazy" id="" width="auto" height="auto" alt="The git checkout command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=112f4f9e88" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">With the command above, you can retrieve the state of a file from a specific commit or branch and apply it to your current working branch.<p.new.line><h2 id="">Adding new origins from forked repositories<h2.new.line><p id="">Have you ever forked a repository to submit a pull request and, a few days later, ended up out of sync with the original repository?<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f7b3f0c56ec451439bb7_raycast-untitled%20(15)-min.png" loading="lazy" id="" width="auto" height="auto" alt="A command to add to a new repository."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=03d04484a9" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">If you’ve ever encountered that situation, you may have already run the command above. It permits you to add the original repository to your forked repository to be able to pull the changes out of the original repository. Once you run the above command, you can perform a <em id="">git pull</em> to pull the changes from your forked to the original repo you just added. <strong id="">Tip</strong>: You can replace the <em id="">original</em> keyword with whatever name allows you to identify the source better. However, take care not to erase an existing source.<p.new.line><h2 id="">Stash<h2.new.line><p id="">Store the changes in a dirty working directory.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f81d6761bbc7be0dfa1b_raycast-untitled%20(16)-min.png" loading="lazy" id="" width="auto" height="auto" alt="The git stash command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=889f40aac7" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">The stash command is convenient when you want to save some changes you made but want to jump to another branch without committing. For instance, if you try to create a change on the feature branch you are working on and then try to change branches, an error message will appear to tell you that you must have a clean working directory before switching. You then have two solutions: committing or stashing.<p.new.line><p id="">By using <em id="">stash</em>, Git will keep your changes, and as soon as you need them, you can re-invoke those changes by using:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f846d6c0090a81a9ef97_raycast-untitled%20(17)-min.png" loading="lazy" id="" width="auto" height="auto" alt="Using git stash."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=0f0b418807" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><h2 id="">Shortcuts<h2.new.line><p id="">Productivity at a glance.<p.new.line><h3 id="">Go back to the previous branch<h3.new.line><p id="">Do you know what <em id="">cd -</em> is doing? It permits you to go back to the previous path you were on.You can use the same mechanism as switching branches to return to a the branch you were previously on.<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f8816761bb46750dfd16_raycast-untitled%20(18)-min.png" loading="lazy" id="" width="auto" height="auto" alt="The git checkout command."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=79f942bc19" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Git is a tool you will use almost every day during your career as a software engineer. You will type the same commands thousands and thousands of times. What if, instead of writing the full command each time, you wrote a couple of letters to gain time and productivity?<p.new.line><p id="">Git thought of that by introducing Git aliases:<p.new.line><figure id="" class="w-richtext-figure-type-image w-richtext-align-fullwidth" style="max-width:1040px" data-rt-type="image" data-rt-align="fullwidth" data-rt-max-width="1040px"><div id=""><img src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/62d0f8a965832045dabb3afd_raycast-untitled%20(19)-min.png" loading="lazy" id="" width="auto" height="auto" alt="Creating git aliases."><div.new.line><figcaption id=""><a href="https://user-3863d558-45a9-40e6-9dff-136019435fd6-fhcmbheklq-uc.a.run.app/?p=5b4642bfcd" target="_blank" id="">Save to Pieces</a></figcaption><figure.new.line><p id="">Do not hesitate to create new aliases for other commands you type a lot.<p.new.line><h2 id="">Conclusion<h2.new.line><p id="">For many, the learning curve for Git is pretty steep, but with a few go-to commands, you should be able to cover most operations you would like to perform in&nbsp;Git. One downside many point to when working with Git is that there is no graphic interface since it is CLI&nbsp;based, but if you are in the camp of people who want a more visual tool, be sure to check out <a href="https://www.gitkraken.com/" target="_blank" id="">GitKraken</a> to get a more visual interface to interact with Git. <p.new.line><p id="">A big part of becoming more comfortable with Git involves time and practice, but two resources in particular helped me improve faster: <p.new.line><p id="">The official git documentation: <a href="https://git-scm.com/" target="_blank" id="">https://git-scm.com/</a> and this <a href="https://www.amazon.com/Version-Control-Git-collaborative-development/dp/1449316387" target="_blank" id="">book</a>: <em id="">Version Control with Git: Powerful tools and techniques for collaborative software development. </em><p.new.line><p id=""><em id="">‍</em>Be sure to check them out if you are trying to level up your knowledge as well; I can guarantee it will be worth you
