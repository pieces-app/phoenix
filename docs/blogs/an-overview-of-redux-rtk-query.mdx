![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd7ae786625c604c44df8d_query_0b75168b1c33cf49fe464d0ae1223a0b_2000.jpeg)
"data-4; react-7"
# An Overview of Redux RTK Query
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<p>Have you ever heard of the Redux Toolkit? State management was developed from Redux and is known as the Redux Toolkit. The boilerplate code for Redux can be minimized using the Redux Toolkit, offering an excellent choice for both beginners and experienced developers. The Redux Toolkit has a ton of features, one of which is the RTK Query (Redux ToolKit Query), which is what we&#x27;ll be exploring in this article.<p.new.line><p><strong>Prerequisites</strong><p.new.line><ul><li>Knowledge of React and Redux Toolkit.<li.new.line><li>Node.js installed on your machine.<li.new.line><li>Knowledge of CRUD operations with Fetch or Axios.<li.new.line><ul.new.line><p>In this article, we’ll learn about RTK Query and how to utilize it in React to fetch data. For this, we&#x27;ll use information from a fictitious JSON server to develop a straightforward to-do application.<p.new.line><p>The <u><a href="https://redux-toolkit.js.org/rtk-query/overview" target="_blank" rel="noopener noreferrer">RTK Query</a></u> is a data retrieval and caching tool that is quite effective. It lets you avoid having to create data fetching and caching logic manually. RTK Query intended to simplify common instances for data loading in a web application. For example, usually, web applications perform CRUD operations from a server and maintain synchronization between the cached data on the client and the server.<p.new.line><p>The Redux Toolkit package installation comes with RTK Query, which includes the following API:<p.new.line><ul><li><strong><u><a href="https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery" target="_blank" rel="noopener noreferrer">fetchBaseQuery()</a></u>: </strong>This is a condensed fetch wrapper that seeks to make requests easier. It’s designed to be the <code>baseQuery</code> that most developers should use with <code>createApi</code>.<li.new.line><li><strong><u><a href="https://redux-toolkit.js.org/rtk-query/api/createApi" target="_blank" rel="noopener noreferrer">createApi()</a></u>: </strong>This<strong> </strong>is the foundation of RTK Query&#x27;s features. It enables you to specify a collection of &quot;endpoints&quot; that specify how to get data from async sources, such as backend APIs and other async sources, along with the setting of how to get the data and convert it. <code>createApi()</code> makes an &quot;API slice&quot; structure for you that comprises Redux logic and, optionally, React hooks, which enable you to fetch and cache data easily.<li.new.line><li><strong><u><a href="https://redux-toolkit.js.org/rtk-query/api/ApiProvider" target="_blank" rel="noopener noreferrer">&lt;ApiProvider/&gt;</a></u></strong>: You can use this as a <code>Provider</code> if you don&#x27;t already have a Redux store.<li.new.line><li><strong><u><a href="https://redux-toolkit.js.org/rtk-query/api/setupListeners" target="_blank" rel="noopener noreferrer">setupListeners()</a></u>: </strong>This is a tool for enabling the <code>refetchOnFocus</code> and <code>refetchOnReconnect</code> characteristics. It requires the delivery strategy from your store. You can provide a callback for more precise control by doing <code>setupListeners(store.dispatch)</code>, which will configure listeners with the suggested defaults.<li.new.line><ul.new.line><h2 id="3tdd5">Scaffolding a New React Project<h2.new.line><p>It’s relatively easy to get started with React. You can use the React project creation tool to scaffold a new project with a few sample files to begin.<p.new.line><p>Use the terminal to run the following command to start a new React project:<p.new.line><pre>yarn create react-app react-RTK Query</pre><p>Once the project is created, remove the unnecessary files from the src folder after the project has been created.<p.new.line><p>Run the following command from the terminal to install the form library:<p.new.line><pre>yarn add @reduxjs/toolkit react-redux</pre><h3 id="fd4fl">Configuring the Redux Store<h3.new.line><p>RTK Query will cache the data it has downloaded from the server in the Redux store, but to allow this, the store must first be configured. The Redux store has to be updated using the Redux slice reducer, and the custom middleware is generated automatically when the API slice is created.<p.new.line><p>Let&#x27;s make a file called store.js in the src directory, our Redux store, and head over to our index.js file to enclose our <code>&lt;App/&gt;</code> with a provider:<p.new.line><h4 id="11rbt">Step 1<h4.new.line><pre>import { configureStore, getDefaultMiddleware } from &quot;@reduxjs/toolkit&quot;;<br><br>import { todoApi } from &quot;./TodoApi&quot;;<br><br>export const store = configureStore({<br>  reducer: {<br>    [todoApi.reducerPath]: todoApi.reducer,<br>  },<br>  middleware: (getDefaultMiddleware) =&gt;<br>    getDefaultMiddleware().concat(todoApi.middleware),<br>});</pre><p><em>Configuration of Redux store</em><p.new.line><h4 id="egqac">Step 2<h4.new.line><pre>import { Provider } from &quot;react-redux&quot;;<br>import { store } from &quot;./Services/Store&quot;;<br>const root = ReactDOM.createRoot(document.getElementById(&quot;root&quot;));<br>root.render(<br>  &lt;React.StrictMode&gt;<br>    &lt;Provider store={store}&gt;<br>      &lt;App /&gt;<br>    &lt;/Provider&gt;<br>  &lt;/React.StrictMode&gt;<br>);</pre><p><em>Wrapping the <code>&lt;App/&gt;</code> component with a provider</em><p.new.line><h2 id="bpa33">Implementing CRUD Operations<h2.new.line><h3 id="ai209">Queries<h3.new.line><p>The most typical application of RTK Query is with CRUD operations. However, you are generally advised to only use queries for requests that receive data. A query operation can be performed with any fetching data library. It’s best to use a Mutation for anything that modifies data on the server or could potentially invalidate the cache.<p.new.line><p>By default, RTK Query includes <code>fetchBaseQuery</code>, a lightweight fetch wrapper that automatically manages request headers and answers parsing in a manner akin to that of widely used libraries like Axios.<p.new.line><p>Let&#x27;s begin with creating a new file called <code>TodoApi.js</code> and import the following:<p.new.line><pre>import { createApi, fetchBaseQuery} from &quot;@reduxjs/toolkit/query/react&quot;;<br><br>export const todoApi = createApi({<br>  reducerPath: &quot;todoApi&quot;,<br>  baseQuery: fetchBaseQuery({<br> baseUrl: &quot;https://jsonplaceholder.typicode.com&quot;,<br>  }),<br>  endpoints: (builder) =&gt; ({})<br>});</pre><p>The <code>createApi()</code> takes an object with the following properties:<p.new.line><p><u><a href="https://redux-toolkit.js.org/rtk-query/api/createApi#reducerpath" target="_blank" rel="noopener noreferrer">reducerPath</a></u>: This particular key specifies the location of the cache&#x27;s storage in the Redux store.<p.new.line><p><u><a href="https://redux-toolkit.js.org/rtk-query/api/createApi#basequery" target="_blank" rel="noopener noreferrer">baseQuery</a></u>: This enables us to construct a query by only supplying the base URL — each endpoint&#x27;s default query for data requests.<p.new.line><p><u><a href="https://redux-toolkit.js.org/rtk-query/api/createApi#endpoints" target="_blank" rel="noopener noreferrer">Endpoints</a></u> This is a collection of activities that you want to be carried out on your server. With the help of the builder syntax, you define them as an object.<p.new.line><p><em>N/B: There are two basic endpoint types: <u><a href="https://redux-toolkit.js.org/rtk-query/usage/queries" target="_blank" rel="noopener noreferrer">query</a></u> and <u><a href="https://redux-toolkit.js.org/rtk-query/usage/mutations" target="_blank" rel="noopener noreferrer">mutation</a></u>.</em><p.new.line><p><strong>Query: </strong>They serve as endpoints for requests to READ data, specifically for reading data from the server.<p.new.line><p><strong>Mutation: </strong>These data updates are sent to the server through mutations, and the local cache is updated. Mutations may also invalidate cached information and necessitate re-fetches, e.g., CREATE, UPDATE, DELETE.<p.new.line><h3 id="5qe17">Specifying endpoints<h3.new.line><pre>endpoints: (builder) =&gt; ({<br>    addTodo: builder.mutation({<br>      query: (todo) =&gt; ({<br>        url: &quot;/posts&quot;,<br>        method: &quot;POST&quot;,<br>        body: JSON.stringify({<br>          title: todo.title,<br>          body: todo.body,<br>          id: todo.id,<br>        }),<br>        headers: {<br> &quot;Content-type&quot;: &quot;application/json; charset=UTF-8&quot;,<br>        },<br>      }),<br>      invalidatesTags: [&quot;Todo&quot;]<br>    }),<br>    getAllTodos: builder.query({<br>      query: () =&gt; &quot;/posts&quot;,<br>      providesTags: [&quot;Todo&quot;]<br><br>    }),<br>    updateTodo: builder.mutation({<br>      query: ({ id, ...todo }) =&gt; ({<br>        url: &#x60;/posts/${id}&#x60;,<br>        method: &quot;PUT&quot;,<br>        body: JSON.stringify({<br>          title: todo.title,<br>          body: todo.body,<br>        }),<br>        headers: {<br> &quot;Content-type&quot;: &quot;application/json; charset=UTF-8&quot;,<br>        },<br>      }),<br>      invalidatesTags: [&quot;Todo&quot;]<br><br>    }),<br>    deleteTodo: builder.mutation({<br>      query: (id) =&gt; ({<br>        url: &#x60;/posts/${id}&#x60;,<br>        method: &quot;DELETE&quot;,<br>      }),<br>      invalidatesTags: [&quot;Todo&quot;]<br><br>    }),<br>  })</pre><p>These are the endpoints for performing the <strong>CRUD </strong>operations:<p.new.line><p><strong><em>addTodo</em></strong>: Endpoint of a mutation for creating a todo.<p.new.line><p><strong><em>getAllTodos</em></strong>: Query endpoint in charge of retrieving all the todos from the server.<p.new.line><p><strong><em>updateTodo</em></strong>: Endpoint of a mutation for updating a todo.<p.new.line><p><strong><em>deleteTodo</em></strong>: Endpoint of a mutation for deleting a todo.<p.new.line><p>Now that we have our endpoints, you may be wondering, “How can we utilize them?”<p.new.line><p>The RTK Query automatically generates a React hook for us to access the endpoints, and they usually begin with &quot;use*NameOfEndpoint**Endpoint type*:<p.new.line><pre>//auto generated hook<br>export const {<br>  useAddTodoMutation,<br>  useDeleteTodoMutation,<br>  useGetAllTodosQuery,<br>  useUpdateTodoMutation,<br>} = todoApi;</pre><p>Auto-Generated Hook<p.new.line><h3 id="22ifm">Fetch All Todos<h3.new.line><p>Let&#x27;s head over to our App.js file, where we display our todos to the DOM. We also need to import the auto-generated hook:<p.new.line><pre>import { useGetAllTodosQuery } from &quot;./Services/TodoApi&quot;;</pre><p>When a query hook is called, it returns an object with properties like the most recent information for the query request and status booleans for the request&#x27;s lifecycle state. The most popular properties are shown below:<p.new.line><pre>const { data, error, isLoading, isFetching, refetch } = useGetAllTodosQuery();</pre><p><em>Destructuring data from the auto-generated hook</em><p.new.line><p><strong>data</strong>: This is the most recent result returned, if any.<p.new.line><p><strong>error</strong>: This results in an error, if any.<p.new.line><p><strong>isLoading</strong>: When true, it means that the Query is presently loading for the first time and that no data has been returned. The first request sent out will be fulfilled this way; however, subsequent requests won&#x27;t.<p.new.line><p><strong>isFetching</strong>: When true, it shows that the Query is currently retrieving data, but it may already contain information from a previous request. This will be true for both the initial request sent and subsequent ones.<p.new.line><pre>&lt;div&gt;<br>     {error &amp;&amp; &lt;p&gt;Something went wrong&lt;/p&gt;}<br>      {isFetching &amp;&amp; &lt;p&gt;fetching ...&lt;/p&gt;}<br>     {isLoading &amp;&amp; &lt;p&gt;Loading ...&lt;/p&gt;}<br>      {data?.map((todo) =&gt; (<br> &lt;Card key={todo.id} id={todo.id} todos={todo.body} /&gt;<br>      ))}<br> &lt;/div&gt;</pre><p><em>Mapping through the data to display todos</em><p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The todos output." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/6356b285b0edab846d3058cd_image2_286b87901df63098fd6efda612e7aefd_800.png"><div.new.line><figcaption><em>Displaying todos output</em></figcaption><figure.new.line><h3 id="82glh">Add Todo<h3.new.line><p>To add a todo, we need to pass an object with the properties title, body and a unique id to the <code>addtodo</code><strong> </strong>mutation endpoint that we implemented earlier.<p.new.line><p>Let&#x27;s head over to our <code>Modal.js</code> file, where we’ll create a new todo:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="The dialog to add a todo." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/6356b285b0edabbf113058b9_image1_e06c93d3dbb6016170e65e92380350b6_800.png"><div.new.line><figcaption>Adding a todo</figcaption><figure.new.line><pre>import { useAddTodoMutation } from &quot;./Services/TodoApi&quot;;</pre><pre>const [addTodo, result] = useAddTodoMutation();</pre><p>The mutation hook returns a tuple unlike that of the Query. The &quot;trigger&quot; function is the first item in the tuple, and an object with status, error, and data is the second item.<p.new.line><p>Now that we know that <code>addTask</code><strong> </strong>is a trigger function, we need to pass in an object that has the properties we specified in the <code>addTask</code><strong> </strong>endpoint:<p.new.line><pre>//add a todo<br> const addTodoHandler = () =&gt; {<br>    addTodo({<br>      title: todo.title,<br>      body: todo.body,<br>      id: Math.floor(Math.random() * 100),<br>    })<br>      .unwrap()<br>      .then((data) =&gt; {<br> console.log(data);<br>      });<br>// force re-fetches the data<br>refetch()<br><br>};</pre><p>The <code>unwrap()</code><strong> </strong>function helps if you need to access the error or success payload immediately after a mutation. Wherever we refer to the <code>addTodoHandler</code><strong> </strong>in our app, a new todo will be created. However, our UI won&#x27;t be updated until the page is refreshed.<p.new.line><p>You can use the refetch method returned as a result property from a <code>useQuery</code> hook to obtain complete granular control over re-fetching data.<p.new.line><h4 id="5d209">RTK Query Caching<h4.new.line><p><u><a href="https://redux-toolkit.js.org/rtk-query/usage/automated-refetching#tags" target="_blank" rel="noopener noreferrer">Tags</a></u> is a term you can assign to a particular set of data in RTK Query to manage cache and invalidation behavior for re-fetching purposes. When determining if cached data should be affected by a mutation, it can be thought of as a &quot;label&quot; that is attached to the data and read after the change. The <code>providesTags</code> property for the query endpoint is used to provide the tag names to caches, and the <code>invalidatesTags</code> property for the mutation endpoint is used to remove them from caches.<p.new.line><h3 id="4tftj">Update Todo<h3.new.line><p>First, to update a todo, we have to import the mutation hook:<p.new.line><pre>import {useUpdateTodoMutation} from&quot;../../Services/TodoApi&quot;<br><br>const [updateTodo] = useUpdateTodoMutation();</pre><p>Destructuring our trigger function is done with the <code>updateTodo</code><strong>. </strong>We call this when we want a particular todo to be edited by passing in the current todo to be updated:<p.new.line><pre>const UpdateTodoHandler = () =&gt; {<br>    updateTodo({ id, ...todo })<br>      .unwrap()<br>      .then((data) =&gt; {<br> console.log(data);<br>      })<br>      .catch((err) =&gt; {<br> console.log(err);<br>      });<br>  };</pre><h3 id="8mv77">Delete Todo<h3.new.line><p>Also, like our <code>updateTodo</code>,<strong> </strong>we have to import the mutation hook:<p.new.line><pre>import {useDeleteTodoMutation } from &quot;../../Services/TodoApi&quot;;</pre><p>We also have to use our delete trigger function returned from the mutation hook:<p.new.line><pre>const [deleteTodo] = useDeleteTodoMutation();</pre><p>And we&#x27;d call it whenever we want to delete a particular todo, thereby passing the unique <code>id</code> of the todo to be deleted:<p.new.line><pre>const DeleteTodoHandler = () =&gt; {<br><br>deleteTodo({id})<br>      .unwrap()<br>      .then((data) =&gt; {<br> console.log(&quot;Todo deleted&quot;);<br>      })<br>      .catch((err) =&gt; {<br> console.log(err);<br>      });<br>  };</pre><h2 id="6433r">Conclusion<h2.new.line><p>With a simple example like the one above where we perform CRUD operations on a JSON server, we display the obtained data in the UI depending on the request&#x27;s state and cache the information in the form. Therefore, RTK Query not only uses an understandable API, but also significantly minimizes the amount of code written. The functionality of this program can always be expanded, and you can learn more about <strong><u><a href="https://redux-toolkit.js.org/rtk-query/overview" target="_blank" rel="noopener nore
