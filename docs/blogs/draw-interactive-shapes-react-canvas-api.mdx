![](https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63dd7c3ca6ec43690eaac3f4_shapesbuildingwithflutter_40e847cca1555417e18bf9fcfdf41431_2000.jpeg)
"react-7; canvas"
# Drawing interactive shapes with the Canvas API in a React application
> Wed Apr 05 2023 16:53:15 GMT+0000 (Coordinated Universal Time)
<figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Stylized image of a wooden pyramid." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/63ed17c7998a611c201c340d_image_753cbf433885c7d22a1f17532a244573_800.png"><div.new.line><figure.new.line><p>In this blog post, we will build a React application through which we can draw interactive shapes with the help of the Canvas API.<p.new.line><p>We’ll also learn about Canvas HTML elements, the Canvas API, and drawing different shapes with mouse interactions.<p.new.line><p>Without further ado, let’s get started!<p.new.line><p><strong>Prerequisites</strong><p.new.line><p>To follow along with this blog post, I would highly recommend that you review the following topics:<p.new.line><ul><li><u><a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener noreferrer">Basics of React</a></u> and<a href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener noreferrer"> <u>useEffect</u></a>.<li.new.line><li><u><a href="https://reactjs.org/docs/glossary.html#refs" target="_blank" rel="noopener noreferrer">React refs</a></u><li.new.line><li><u><a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics" target="_blank" rel="noopener noreferrer">Basic Javascript</a></u><li.new.line><li><u><a href="https://www.typescriptlang.org/docs/handbook/2/basic-types.html" target="_blank" rel="noopener noreferrer">Basics of typescript</a></u><li.new.line><ul.new.line><h2 id="10o3d">The Canvas HTML Element and the Canvas API<h2.new.line><p><code>&lt;canvas&gt;</code> is an <a href="https://code.pieces.app/blog/introduction-to-html" target="_blank" rel="noopener noreferrer">HTML element</a> that helps you to draw shapes. You can draw shapes inside a canvas element using the Canvas API provided by your browser. This element acts as a container in which you can draw different shapes. To draw inside a <code>canvas</code> element, a context for the element is required. A context is an entity that we can draw shapes on. We can use <code>getContext</code> to get the<u><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D" target="_blank" rel="noopener noreferrer"> CanvasRenderingContext2D</a></u> that returns the 2-D context.<p.new.line><p>Let’s look at a simple React <code>canvas</code> component that draws a rectangle inside an element.<p.new.line><pre>import { useEffect, useRef } from &quot;react&quot;;<br><br>export const Rectangle = () =&gt; {<br> const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null);<br><br>  useEffect(() =&gt; {<br> if (canvasRef.current) {<br> const ctx = canvasRef.current.getContext(&quot;2d&quot;);<br>      ctx?.strokeRect(200, 200, 40, 50);<br>    }<br>  }, []);<br><br> return (<br> &lt;canvas<br>      ref={canvasRef}<br>      width=&quot;400&quot;<br>      height=&quot;350&quot;<br>      style={{ border: &quot;2px solid black&quot; }}<br>    /&gt;<br>  );<br>};</pre><p>Here is what the <code>Rectangle</code> component will render:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="A rendered rectangle drawn with the Canvas API." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/633b16d8be9bdc596aa7df63_image2_23b2664ac95e8b9cc93d84cf6dde5c3f_800.png"><div.new.line><figure.new.line><p>Let’s take a peek into the above <code>Rectangle</code> component:<p.new.line><ul><li>The <code>Rectangle</code> component returns a <code>canvas</code> element whose width and height are set to <code>400px</code> and <code>300px</code>, respectively.<li.new.line><li>We need to make sure that we pass a <code>ref</code> to the <code>canvas</code> element. This will help us to access the different properties of the <code>canvas</code> element.<li.new.line><li>Lastly, we want to draw inside the <code>canvas</code> element once the component is rendered. To do so, we’ll write a piece of code that gets the <code>canvas</code> element’s 2-D context using <code>getContext(&quot;2d&quot;)</code> and uses the above context to draw a rectangle with a function<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeRect" target="_blank" rel="noopener noreferrer"> <code><u>strokeRect</u></code></a>. <li.new.line><ul.new.line><p>Now, with this understanding, let’s dive into drawing some shapes.<p.new.line><h2 id="nhk">Drawing a Rectangle on the Canvas<h2.new.line><p>In this section, we’re going to talk about drawing a rectangle upon clicking the canvas, as in the gif below:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Gif showing a new rectangle being created with every click." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/633b3588e6f6a63f758bcb3a_ezgif_com-gif-maker17_a33e09863908ec045743484815004b8d.gif"><div.new.line><figure.new.line><p>If we think about building an app like this in React or in JS, then we need to consider two important points: First, how we get the cursor’s x and y coordinates for drawing onto the canvas, and second, how we’re going to draw on the mouse click.<p.new.line><p>Let’s investigate these points further:<p.new.line><h3 id="dqf4l">How would we get the cursor’s x and y coordinates so that we can draw it onto the canvas?<h3.new.line><ul><ul><li>In this scenario, we can simply add an event listener on the <code>mousemove</code> event.<li.new.line><li>The handler we will attach will simply set the x and y coordinates to the values that are relative to the edges of the given element, like this: <li.new.line><ul.new.line><ul.new.line><pre>const handleCursorMovement = (event) =&gt; {<br> let rect = event.target.getBoundingClientRect();<br> return {<br>      x: event.clientX - rect.left,<br>      y: event.clientY - rect.top<br>    };<br>  };</pre><ul><ul><li>The <code>x-coordinate</code> is the difference between the viewport&#x27;s x-coordinate and the distance of the current object from the left edge of the viewport. This will give us the x-coordinate inside the rectangle. In this case, the current object is what we’re hovering over.<li.new.line><li>Similarly, we have <code>y</code> where it is the difference between the viewport’s y-coordinate and the distance of the current object from the top edge of the viewport. In this case, the current object is what we’re hovering over.<li.new.line><ul.new.line><ul.new.line><p>You can read more about <code>clientX</code> and <code>getBoundingClientRect</code> <u><a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX" target="_blank" rel="noopener noreferrer">here</a></u> and<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener noreferrer"> <u>here</u></a>. This is a really useful scenario, and it will be used in most of our examples.<p.new.line><p>So, let’s wrap this logic into a hook so that we can use it in any component we want.<p.new.line><p>Copy-paste the below code into a file named <code>useMousePosition.tsx</code><p.new.line><pre>import { useEffect, useState } from &quot;react&quot;;<br><br>const useMousePosition = (<br>  global: boolean = false<br>): [{ x: number; y: number }, (event: MouseEvent) =&gt; void] =&gt; {<br> const [mouseCoords, setMouseCoords] = useState&lt;{<br>    x: number;<br>    y: number;<br>  }&gt;({<br>    x: 0,<br>    y: 0<br>  });<br><br> const handleCursorMovement = (event: MouseEvent): void =&gt; {<br> //@ts-ignore<br> let rect = event.target.getBoundingClientRect();<br>    setMouseCoords({<br>      x: event.clientX - rect.left,<br>      y: event.clientY - rect.top<br>    });<br>  };<br>  useEffect(() =&gt; {<br> if (global) {<br> window.addEventListener(&quot;mousemove&quot;, handleCursorMovement);<br><br> return () =&gt; {<br> window.removeEventListener(&quot;mousemove&quot;, handleCursorMovement);<br>      };<br>    }<br>  }, [global]);<br><br> return [mouseCoords, handleCursorMovement];<br>};<br><br>export default useMousePosition;</pre><ul><li>This hook returns an array that consists of two things: the current cursor coordinates, and a function that handles the setting of these coordinates.<li.new.line><li>This function also accepts a parameter called “global.” If set to <code>true</code>, this parameter makes sure that a listener is attached to the <code>mousemove</code> event over the entire window.<li.new.line><li>The default value of the <code>global</code> parameter is set to false.<li.new.line><ul.new.line><h3 id="bagjm">How are we going to draw on the mouse click?<h3.new.line><ul><li>In this scenario, we’re going to draw inside the <code>canvas</code> whenever the user clicks on the <code>canvas</code>.<li.new.line><li>To do this, we are going to bind the <code>canvas</code> element with a function that executes itself on a click. It’s as simple as adding an <code>onClick</code> attribute to it.<li.new.line><ul.new.line><p>To wrap up this scenario, place the following code inside a file named <code>Square.tsx</code>:<p.new.line><pre>import { useRef } from &quot;react&quot;;<br>import useMousePosition from &quot;./hooks/useMousePosition&quot;;<br><br>export default function Sqaure() {<br> const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null);<br> const [coords, handleCoords] = useMousePosition(true);<br><br> return (<br> &lt;&gt;<br> &lt;h1&gt;Sqaure on click&lt;/h1&gt;<br> &lt;canvas<br>        ref={canvasRef}<br>        width=&quot;400&quot;<br>        height=&quot;350&quot;<br>        style={{ border: &quot;2px solid black&quot; }}<br>        onClick={(e) =&gt; {<br>          handleCoords((e as unknown) as MouseEvent);<br>          if (canvasRef.current) {<br>            const ctx = canvasRef.current.getContext(&quot;2d&quot;);<br>            ctx?.strokeRect(coords.x, coords.y, 40, 50);<br>          }<br>        }}<br>      &gt;&lt;/canvas&gt;<br> &lt;button<br>        onClick={() =&gt; {<br>          if (canvasRef.current) {<br>            const ctx = canvasRef.current.getContext(&quot;2d&quot;);<br>            ctx?.clearRect(0, 0, 400, 350);<br>          }<br>        }}<br>      &gt;<br>        CLEAR<br> &lt;/button&gt;<br> &lt;/&gt;<br>  );<br>}</pre><p>The output will look something like below:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="Several rectangles on a canvas." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/633b3587e6f6a6a29c8bcb1f_image4_359a92c552d59aacbd648a8d35cd7f24_800.jpeg"><div.new.line><figure.new.line><p>In this, we also make sure to provide a “clear” button so that the Canvas can be cleared.<p.new.line><p>As you can see from the above code, we have attached a function on the <code>onClick</code> attribute of the canvas:<p.new.line><pre>&lt;canvas<br>        ref={canvasRef}<br>        width=&quot;400&quot;<br>        height=&quot;350&quot;<br>        style={{ border: &quot;2px solid black&quot; }}<br>        onClick={(e) =&gt; {<br>          handleCoords((e as unknown) as MouseEvent);<br> if (canvasRef.current) {<br> const ctx = canvasRef.current.getContext(&quot;2d&quot;);<br>            ctx?.strokeRect(coords.x, coords.y, 40, 50);<br>          }<br>        }}<br>      &gt;&lt;/canvas&gt;</pre><p>This function will do the following things:<p.new.line><ul><li>It will execute the <code>handleCoords</code> function that sets the current mouse position coordinates.<li.new.line><li>Then it gets the current canvas’s 2-D context.<li.new.line><li>Finally, it draws a rectangle using the <code>strokeRect</code> function via passing the x and y coordinates of the mouse pointer.<li.new.line><ul.new.line><p>Let’s go ahead and look at what else we can draw with React <code>canvas</code>.<p.new.line><h2 id="54r1a">Animate Canvas Objects<h2.new.line><p>In this section of the article, we’re going to talk about the interesting stuff: the animation of the objects present inside the canvas.<p.new.line><p>Things that we are going to do in this section are:<p.new.line><ul><li>Draw the shape on the canvas<li.new.line><li>Move the shape on the canvas at a regular interval to get the animation effect<li.new.line><ul.new.line><p>The animation that we are building here is a ball moving continuously in a horizontal direction. Here is a glimpse of it:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="A ball moving across a rectangle." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/633b16d8be9bdc66f8a7df65_image1_c54d6c97521ed8487603836e82611a80.gif"><div.new.line><figure.new.line><p>To draw a circle, we can use the below code:<p.new.line><pre>export const drawCircle = (<br>  ctx: CanvasRenderingContext2D,<br>  circleDims: {<br>    radius: number;<br>    lineWidth: number;<br>    strokeStyle: string;<br>    colorFill?: string;<br>    startX: number;<br>    startY: number;<br>  },<br>  rectDims: { w: number; h: number } = { w: 400, h: 3500 }<br>) =&gt; {<br> const {<br>    radius,<br>    strokeStyle,<br>    startX,<br>    startY,<br>    lineWidth,<br>    colorFill<br>  } = circleDims;<br>  ctx?.clearRect(0, 0, rectDims.w, rectDims.h);<br>  ctx.lineWidth = lineWidth;<br>  ctx.strokeStyle = strokeStyle;<br><br>  ctx?.beginPath();<br>  ctx?.arc(startX, startY, radius, 0, Math.PI * 2, true);<br>  ctx?.stroke();<br> if (colorFill) {<br>    ctx.fillStyle = colorFill;<br>    ctx.fill();<br>  }<br>};</pre><p>I have wrapped the logic of creating a circle in the function <code>drawCircle</code>. The logic of it is below:<p.new.line><pre>ctx?.clearRect(0, 0, rectDims.w, rectDims.h);<br>  ctx.lineWidth = lineWidth;<br>  ctx.strokeStyle = strokeStyle;<br><br>  ctx?.beginPath();<br>  ctx?.arc(startX, startY, radius, 0, Math.PI * 2, true);<br>  ctx?.stroke();<br> if (colorFill) {<br>    ctx.fillStyle = colorFill;<br>    ctx.fill();<br>  }</pre><ul><li>First, we clear the canvas using the<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/clearRect" target="_blank" rel="noopener noreferrer"> <u><code>clearRect</code></u></a> function.<li.new.line><li>Next, we set the <code>lineWidth</code> of the circumference of the circle/ball.<li.new.line><li>We also set the <code>strokeStyle</code> that sets the color of the border.<li.new.line><li>Then, we start to create a new path using the<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/beginPath" target="_blank" rel="noopener noreferrer"> <u><code>beginPath</code></u></a> function. We make use of the<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/arc" target="_blank" rel="noopener noreferrer"> <u><code>arc</code></u></a> method that helps draw circular arcs with the given x-coordinate, y-coordinate, radius, start and end angle.<li.new.line><li>Once the <code>arc</code> is added as a sub-path, we can draw the arc onto the canvas with the given stroke style using the<a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/stroke" target="_blank" rel="noopener noreferrer"> <code><u>stroke</u></code></a> function.<li.new.line><li>Finally, if the <code>colorFill</code> is available, then it will fill the path with the available <code>fillStyle</code>.<li.new.line><ul.new.line><p>Next, we will make use of this function to create a component that animates the shape.<p.new.line><p>Create a file named <code>Circle.tsx</code> file and place the below code within:<p.new.line><pre>import { useEffect, useRef, useState } from &quot;react&quot;;<br>import { drawCircle } from &quot;./utilities&quot;;<br><br>const Circle = () =&gt; {<br> const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null);<br> const [startX, setStartX] = useState&lt;number&gt;(0);<br>  useEffect(() =&gt; {<br> if (canvasRef?.current) {<br> const ctx = canvasRef.current.getContext(&quot;2d&quot;);<br><br>      requestAnimationFrame(function ball() {<br> //@ts-ignore<br>        drawCircle(ctx, {<br>          radius: 50,<br>          lineWidth: 3,<br>          strokeStyle: &quot;#4F7CAC&quot;,<br>          colorFill: &quot;#4F7CAC&quot;,<br>          startY: 150,<br>          startX<br>        });<br>        setStartX((prevStartX) =&gt; prevStartX + 5);<br>        ctx?.stroke();<br> if (startX &gt; 400) {<br>          setStartX(0);<br>        }<br>      });<br>    }<br>  }, [startX]);<br> return (<br>    &lt;&gt;<br>      &lt;h1&gt;Moving Circle&lt;/h1&gt;<br>      &lt;canvas<br>        ref={canvasRef}<br>        width=&quot;400&quot;<br>        height=&quot;350&quot;<br>        style={{ border: &quot;2px solid black&quot; }}<br>      /&gt;<br>    &lt;/&gt;<br>  );<br>};<br><br>export default Circle;</pre><p>Let’s analyze this code a bit:<p.new.line><ul><li>The <code>Circle</code> component returns a <code>canvas</code> element. This is similar to the <code>Square</code> component that we saw in the earlier section.<li.new.line><li>The aim of this animation is to move the circle continuously in the horizontal direction. So, in this case, we need to make sure we change the x-coordinate. For this, we created a new state variable called <code>startX</code>. We’ll look later at how we update <code>startX</code> continuously.<li.new.line><li>Next, we have a <code>useEffect</code>. This <code>useEffect</code> gets the 2-D context of the canvas and then executes the function <code>requestAnimationFrame</code>.<li.new.line><li><u><code><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener noreferrer">requestAnimationFrame</a></code></u> is a function that tells the browser it needs to perform an animation. The provided function will be executed before the next repaint. In this case, we are going to pass a function, <code>ball</code>, that draws a new circle on every new x-coordinate with the help of <code>startX</code>.<li.new.line><li>We make use of the <code>setStartX</code> update handler that updates the current <code>startX</code> by 5.<li.new.line><li>Lastly, we check if the <code>startX</code> state is crossing the right edge of the canvas. If yes, then we set the value to 0. This ensures that whenever the ball hits the right edge, it can start the animation again from the left edge.<li.new.line><ul.new.line><h2 id="66btf">Moving Shapes with Mouse Events<h2.new.line><p>In this section, we’re going to talk about how we can make the shapes inside the canvas interact with mouse events.<p.new.line><p>The process that we are going to follow is very similar to what we had in the <code>Square</code> component. In the square component, we made use of the <code>onClick</code> attribute of the <code>canvas</code> element to draw a rectangle on the mouse click event. Similarly, we are going to make use of the <code>onMouseMove</code> attribute of the <code>canvas</code> element.<p.new.line><p>Create a file named <code>TrackingBall.tsx</code> and paste the below code:<p.new.line><pre>import { useEffect, useRef } from &quot;react&quot;;<br>import useMousePosition from &quot;./hooks/useMousePosition&quot;;<br>import { drawCircle } from &quot;./utilities&quot;;<br>const MouseBall = () =&gt; {<br> const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null);<br> const [coords, handleCoords] = useMousePosition();<br><br>  useEffect(() =&gt; {<br> if (canvasRef?.current) {<br> const ctx = canvasRef.current.getContext(&quot;2d&quot;);<br><br>      requestAnimationFrame(function ball() {<br> //@ts-ignore<br>        drawCircle(ctx, {<br>          radius: 50,<br>          lineWidth: 3,<br>          strokeStyle: &quot;#4F7CAC&quot;,<br>          colorFill: &quot;#4F7CAC&quot;,<br>          startY: coords.y,<br>          startX: coords.x<br>        });<br>      });<br>    }<br>  }, [coords.x, coords.y]);<br> return (<br> &lt;&gt;<br> &lt;h1&gt;Tracking ball&lt;/h1&gt;<br> &lt;canvas<br>        id=&quot;canvas2&quot;<br>        ref={canvasRef}<br>        width=&quot;400&quot;<br>        height=&quot;350&quot;<br>        onMouseMove={(e) =&gt; {<br>          handleCoords((e as unknown) as MouseEvent);<br>        }}<br>        style={{ border: &quot;2px solid black&quot; }}<br>      &gt;&lt;/canvas&gt;<br> &lt;/&gt;<br>  );<br>};<br><br>export default MouseBall;</pre><p>The <code>MouseBall</code> component is pretty similar to the <code>Square</code> component. The only change is that we are executing the <code>handleCoords</code> function inside the <code>onMouseMove</code> event. Also, we are making use of the <code>requestAnimationFrame</code> function to execute the <code>ball</code> handler on the change of <code>coords.x</code> and <code>coords.y</code>.<p.new.line><p>The final output will look like the below:<p.new.line><figure class="w-richtext-figure-type-image w-richtext-align-center" data-rt-type="image" data-rt-align="center"><div><img alt="A circle that moves with your cursor." src="https://uploads-ssl.webflow.com/6143afec68f555387049efb3/633b16d8be9bdcf695a7df66_image3_a532abd02558e99f2d8e8b8c04186853.gif"><div.new.line><figure.new.line><h2 id="1pu9">Summary<h2.new.line><p>In this article, we talked about the following things:<p.new.line><ul><li>What is a <code>canvas</code> HTML element?<li.new.line><li>How is a Canvas API used to draw inside the canvas?<li.new.line><li>How a Canvas API works with the help of a simple example.<li.new.line><li>Drawing rectangles and circle shapes with the Canvas API.<li.new.line><li>Building a custom hook to track the position of the cursor.<li.new.line><li>How the <code>requestAnimationFrame</code> function can be used.<li.new.line><li>Lastly, we also saw how we can make use of the mouse events to interact with shapes present inside the canvas.<li.new.line><ul.new.line><p>So in this way, we can make use of the <code>canvas</code> HTML element, Canvas API, and React to draw different interactive shapes. <p.new.line>\n\n
